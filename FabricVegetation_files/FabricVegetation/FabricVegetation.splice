{"version":"1014000","info":{"hostAppName":"Maya","hostAppVersion":"2014"},"nodes":[{"name":"DGNode","dependencies":{},"bindings":[{"operator":{"name":"vegetationOp","entry":"vegetationOp","filename":"vegetationOp.kl","kl":"/*\n  Vegetation Operator for growing vegetation around any arbitrary mesh using Fabric:Splice\n  in most DCC's. Have only tested for Maya 2014, haven't tested for other versions or say\n  SoftImage.\n*/\n\n/// \\cond\nrequire Geometry;\nrequire Vegetation; // own extension for Bud objects\n/// \\endcond\n\n// http://mathworld.wolfram.com/SphericalCoordinates.html\n// simple conversion between spherical coordinates and cartesian taken from WolframAlpha\n// information from Wolfram uses left-handed coordinate system so z and y swap\n/// A conversion function from cartesian to spherical coordinates\n/// \\param coords The cartesian coordinates\ninline Vec3 cartesianToSphere(in Vec3 coords) {\n\n  return Vec3(coords.length(), acos(coords.y/coords.length()), atan2(coords.z, coords.x));\n}\n\n/// A conversion function from spherical to cartesian coordinates\n/// \\param dist The distance from origin\n/// \\param phi The angle in the zx-plane, also known as the azimuthal angle\n/// \\param theta The angle from the positive y-axis, also known as the polar angle\ninline Vec3 sphereToCartesian(in Float32 dist,\n                              in Float32 phi,\n                              in Float32 theta) {\n\n  return Vec3(dist*sin(theta)*sin(phi), dist*cos(phi), dist*cos(theta)*sin(phi));\n}\n\n// http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors\n// an efficient method of finding a rotation quaternion from this blog\n// the input vectors should be of unit length\n/// A function to quickly grab a rotation quat from two vectors\n/// \\param a The origin vector\n/// \\param b The 'to' vector\nfunction Quat alignVectors(in Vec3 a,\n                           in Vec3 b) {\n\n  // find the angle between both vectors\n  Float32 real=1.0+a.dot(b);\n  Vec3 axis;\n  // if the both vectors are the parallel, use the x-axis as the turning axis\n  if(real<PRECISION) {\n    axis.set(1.0, 0, 0);\n  }\n  // otherwise, cross both vectors to get the turning axis\n  else {\n    axis=a.cross(b);\n  }\n\n  Quat rotation(axis, real);\n  return rotation.unit(); // normalize quat to have only rotation\n}\n\n/// An operator for evaluating bud sample positions to light effectiveness\n/// \\param bud The active bud with sample positions\n/// \\param fitness The array of scores for each sample position\n/// \\param queryable The shadowing environment given as a spatial queryable object to access the octree\n/// \\param maxSceneSize The corner-to-corner distance of the whole scene\n/// \\param lightPos The positions of each point light in the scene\n/// \\param lightInt The intensities of each point light in the scene\n/// \\param sunPos The position of the sun relative to the origin\n/// \\param quadratic Whether or not the lights should imitate reality with a quadratic falloff\noperator lightFitness<<<index>>>(in Bud bud,\n                                 io Float32 fitness[],\n                                 in SpatialQueryable queryable,\n                                 in Float32 maxSceneSize,\n                                 in Vec3 lightPos[],\n                                 in Scalar lightInt[],\n                                 in Vec3 sunPos,\n                                 in Boolean quadratic) {\n\n  // initialize a float to accumulate the score\n  Float32 lightScore=0;\n  // only evaluate point lights if there are any\n  if(lightPos.size()>0) {\n    for(UInt32 i=0;i<lightPos.size();++i) {\n      // fire ray from bud position to light direction (i.e. backwards) to see\n      // whether it collides with any of the environment\n      Vec3 direction=lightPos[i]-bud.samplePositions[index];\n      Ray ray(bud.samplePositions[index], direction);\n      GeometryLocation blocked=queryable.raycast(ray, false, 0.0, maxSceneSize);\n\n      // if the ray hasn't been blocked by the environment add to the score\n      if(!blocked.isValid()) {\n        // calculate the quadratic falloff depending on the light intensity\n        if(quadratic) {\n          Float32 strength=lightInt[i]/pow(direction.length(), 2.0);\n          Float32 normalized=strength/maxSceneSize;\n          // arbitrary cutoff for the light to be too dim for plant growth\n          if(normalized>=0.01) {\n            lightScore+=normalized;\n          }\n        }\n        // if there's no falloff, just add a score of 1, it will be averaged later\n        else {\n          lightScore+=1.0;\n        }\n      }\n    }\n    // average the light's score to the number of lights\n    lightScore=lightScore/lightPos.size();\n  }\n\n  // also calculate the sun's contribution if available\n  if(!sunPos.almostEqual(Vec3(0))) {\n    Ray ray(bud.samplePositions[index], sunPos);\n    GeometryLocation blocked=queryable.raycast(ray, false, 0.0, maxSceneSize);\n    if(!blocked.isValid()) {\n      // treat the sun as a full strength light, but still average it\n      Float32 lightsAsFloat=lightPos.size();\n      lightScore+=1.0/(lightsAsFloat+1.0);\n    }\n  }\n\n  // quick test to see if distance had failed, if so, don't add the light score\n  // this ensures the final score is 0 and traumatic reiteration happens\n  if(fitness[index]>0) {\n    fitness[index]+=lightScore*0.5;\n  }\n}\n\n/// An operator for evaluating bud sample positions and environment mesh proximity\n/// \\param bud The active bud with sample positions\n/// \\param fitness The array of scores for each sample position\n/// \\param environment The environment mesh for collision\n/// \\param maxSceneSize The corner-to-corner distance of the whole scene\noperator distanceFitness<<<index>>>(io Bud bud,\n                                    io Float32 fitness[],\n                                    in PolygonMesh environment,\n                                    in Float32 maxSceneSize) {\n\n  // initialize a float to accumulate the score\n  Float32 distScore=0;\n  // make it different to the paper, no per-object calculations but instead\n  // take the whole environment as one object, make the program more naive\n  SpatialQueryable queryable=environment;\n  GeometryLocation closest=queryable.getClosest(bud.samplePositions[index], Vec3(1.0), maxSceneSize);\n  // if there is a close polygon\n  if(closest.isValid()) {\n    // grab the normal and position vectors from the polygon and store for later use\n    Vec3 closestNormal=environment.getNormalAtLocation(closest);\n    Vec3 closestPoint=environment.getPositionAtLocation(closest);\n    bud.surfaceNormal=closestNormal;\n    bud.surfacePosition=closestPoint;\n\n    // http://www.miguelcasillas.com/?p=43\n    // check if the point is behind the plane, simple half-space test as there is\n    // a lot of information provided in this situation\n    Vec3 fromPlane=bud.samplePositions[index]-closestPoint;\n    Float32 distanceFromPlane=fromPlane.dot(closestNormal);\n\n    // if the sample is in front of the plane and within the bounds of the scene\n    // add to the score dependant on it's distance relative to the scene's size\n    if(distanceFromPlane>PRECISION && fromPlane.length()<=maxSceneSize) {\n      distScore=1.0-(fromPlane.length()/maxSceneSize);\n    }\n  }\n\n  // blindly add to the fitness as this is the first tropism to be evaluated\n  fitness[index]+=distScore*0.5;\n}\n\n/// An operator for distributing fitness functions for each bud and finding the best sample\n/// \\param activeBuds The active bud with sample positions\n/// \\param samples The number of random potential positions the bud will grow to next\n/// \\param collision The environment mesh for collision\n/// \\param shadowing The environment mesh for shadowing\n/// \\param vegetation The vegetation mesh itself for self collision\n/// \\param branchThick The maximum radius of the vine\n/// \\param lightPos The positions of each point light in the scene\n/// \\param lightInt The intensities of each point light in the scene\n/// \\param sunPos The position of the sun relative to the origin\n/// \\param quadratic Whether or not the lights should imitate reality with a quadratic falloff\noperator evaluateSamples<<<index>>>(io Bud activeBuds[],\n                                    in Integer samples,\n                                    in PolygonMesh collision,\n                                    in PolygonMesh shadowing,\n                                    in PolygonMesh vegetation,\n                                    in Scalar branchThick,\n                                    in Vec3 lightPos[],\n                                    in Scalar lightInt[],\n                                    in Vec3 sunPos,\n                                    in Boolean quadratic) {\n\n  // prepare an array to store the scores of each sample position\n  Float32 fitness[];\n  fitness.resize(samples);\n  // evaluate the distance from collision mesh\n  distanceFitness<<<samples>>>(activeBuds[index], fitness, collision, 20.0);\n  // evaluate the amount of light arriving with shadowing mesh and lights\n  lightFitness<<<samples>>>(activeBuds[index], fitness, shadowing, 20.0, lightPos, lightInt, sunPos, quadratic);\n\n  // now find the best sample by comparing for the highest score\n  UInt32 best=0;\n  for(UInt32 n=0;n<samples;++n) {\n    // replace the best index if maxing the two values gives the new value\n    if(Math_max(fitness[best], fitness[n])==fitness[n]) {\n      best=n;\n    }\n  }\n\n  // kill the bud if the best sample is not viable, i.e. prepare it for traumatic reiteration\n  if(fitness[best]==0) {\n    activeBuds[index].active=false;\n  }\n  // otherwise step the position\n  else {\n    // check if the vegetation will collide with itself by raycasting to the vegetation mesh\n    activeBuds[index].stepPosition(best);\n    Vec3 direction=activeBuds[index].getDirection();\n    Ray ray(activeBuds[index].prvPosition, direction);\n    SpatialQueryable queryable=vegetation;\n    GeometryLocation blocked=queryable.raycast(ray, false, 0.0, direction.length());\n    // if so, offset the growth slightly by the thickness of the vine using the surface normal\n    if(blocked.isValid()) {\n      Vec3 offset=activeBuds[index].surfaceNormal*branchThick;\n      activeBuds[index].offsetPosition(offset);\n    }\n  }\n}\n\n/// An operator to generate a number of sample positions for each bud within a conical allowance\n/// \\param activeBuds The active bud for storing sample positions\n/// \\param samples The number of random potential positions the bud will grow to next\n/// \\param distribution The allowed conical angle of positions to deviate from growth direction\n/// \\param minStep The minimum distance to grow per step\n/// \\param maxStep The maximum distance to grow per step\n/// \\param seed A random seed to vary the pseudo-random numbers per step\noperator generateSamples<<<index>>>(io Bud activeBuds[],\n                                    in Integer samples,\n                                    in Float32 distribution,\n                                    in Scalar minStep,\n                                    in Scalar maxStep,\n                                    in UInt32 seed) {\n\n  // get the current growth direction\n  Vec3 direction=activeBuds[index].getDirection();\n\n  // generate sample positions\n  for(UInt32 n=0;n<samples;++n) {\n    // need to generate points in spherical coordinates, which uses 2 angles and dist\n    // first phi, which is in the range 0-pi spherically, but limited by distribution\n    Float32 phi=mathRandomFloat32(seed+1, n+1)*distribution;\n    // then theta, which is in the range 0-2pi spherically\n    Float32 theta=mathRandomFloat32(seed+1823, (n+1)*2)*TWO_PI;\n    // distance will range from tiny scalar PRECISION to the direction length\n    Float32 dist=minStep+mathRandomFloat32(seed+71045, (n+1)*3)*maxStep;\n    // using given spherical values, convert it to cartesian coordinates\n    Vec3 random=sphereToCartesian(dist, phi, theta);\n\n    // need to find the rotation from up vector to direction vector\n    // then rotate random by the rotation to align with direction vector\n    Quat rotation=alignVectors(Vec3(0, 1.0, 0), direction.unit());\n    random=rotation.rotateVector(random);\n    // add the random sample to the list of sample positions\n    activeBuds[index].samplePositions[n]=activeBuds[index].position+random;\n  }\n}\n\n/// A function to quickly create an approximate circle profile for extrusion\n/// \\param radius The radius of the circle\nfunction Vec3[] createProfile(in Float32 radius) {\n  // A slightly smaller radius for some points along the circle\n  Float32 radiusS=radius*0.66;\n  // define a basic circle profile\n  Vec3 profile[];\n  profile.push(Vec3(radius, 0, 0));\n  profile.push(Vec3(radiusS, 0, radiusS));\n  profile.push(Vec3(0, 0, radius));\n  profile.push(Vec3(-radiusS, 0, radiusS));\n  profile.push(Vec3(-radius, 0, 0));\n  profile.push(Vec3(-radiusS, 0, -radiusS));\n  profile.push(Vec3(0, 0, -radius));\n  profile.push(Vec3(radiusS, 0, -radiusS));\n\n  return profile;\n}\n\n/// The main operator to carry out the vegetation growth, more detail is found in the code's comments\n/// \\param envCollide The raw input meshes for collision\n/// \\param envShadow The raw input meshes for shadowing\n/// \\param collideMerged The processed environment mesh for collision\n/// \\param shadowMerged The processed environment mesh for shadowing\n/// \\param vegeBranches The output vegetation mesh holding only the branches\n/// \\param vegeLeaves The output vegetation mesh holding only the leaves\n/// \\param seeds The positions of each seed within the scene\n/// \\param sunPos The position of the sun relative to the origin\n/// \\param lightPos The positions of each point light in the scene\n/// \\param lightInt The intensities of each point light in the scene\n/// \\param quadratic Whether or not the lights should imitate reality with a quadratic falloff\n/// \\param prepareMeshes Whether or not the acceleration structures should be calculated\n/// \\param buildGrowth Whether or not the actual plant growth should be carried out\n/// \\param steps The number of iterations of the vegetation should accumulate\n/// \\param samples The number of random potential positions the bud will grow to next\n/// \\param distribution The allowed conical angle of positions to deviate from growth direction\n/// \\param minStep The minimum distance to grow per step\n/// \\param maxStep The maximum distance to grow per step\n/// \\param budChance The chance for a lateral bud to grow on the vine branches\n/// \\param branchChance The chance for a lateral bud to activate\n/// \\param branchThick The maximum radius of the vine\n/// \\param leafSize The size of the leaf planes\n/// \\param leafChance The chance on each step for a leaf to grow\noperator vegetationOp(in PolygonMesh envCollide[],\n                      in PolygonMesh envShadow[],\n                      io PolygonMesh collideMerged,\n                      io PolygonMesh shadowMerged,\n                      io PolygonMesh vegeBranches,\n                      io PolygonMesh vegeLeaves,\n                      in Vec3 seeds[],\n                      in Vec3 sunPos,\n                      in Vec3 lightPos[],\n                      in Scalar lightInt[],\n                      in Boolean quadratic,\n                      io Boolean prepareMeshes,\n                      io Boolean buildGrowth,\n                      in Integer steps,\n                      in Integer samples,\n                      in Scalar distribution,\n                      in Scalar minStep,\n                      in Scalar maxStep,\n                      in Scalar budChance,\n                      in Scalar branchChance,\n                      in Scalar branchThick,\n                      in Scalar leafSize,\n                      in Scalar leafChance) {\n\n  // give an approximation of the number of queries an acceleration mesh will receive\n  // this is found from the number of samples each seed might take multiplied by 100\n  // as a buffer for the potential number of active buds at once, per step with a query\n  // per light as well\n  UInt32 approxQueries=samples*seeds.size()*100*steps*lightPos.size();\n\n  // separated a chunk of code out to simply calculate acceleration structures as this takes\n  // quite a large amount of computation depending on the complexity of the scene, e.g. for\n  // speedtree a, it takes at least 9 seconds on 4 cores and takes at least 600mb+ in the maya scene\n  if(prepareMeshes) {\n    // time the accerelation structure creation\n    UInt64 start=getCurrentTicks();\n\n    // clear any previous meshes and clean up the associated acceleration structure\n    collideMerged.removeSpatialQueryAcceleration();\n    collideMerged.clear();\n    shadowMerged.removeSpatialQueryAcceleration();\n    shadowMerged.clear();\n\n    // merge collision and shadowing mesh into one mesh for building acceleration structure\n    Xfo xfo[];\n    xfo.resize(envCollide.size());\n    collideMerged.mergeMeshes(envCollide, xfo, false);\n    xfo.resize(envShadow.size());\n    shadowMerged.mergeMeshes(envShadow, xfo, false);\n\n    // prepare both meshes for spatial partitioning as an octree (default)\n    collideMerged.prepareForSpatialQueries(approxQueries, null);\n    shadowMerged.prepareForSpatialQueries(approxQueries, null);\n\n    // count and calculate the processing time\n    UInt64 end=getCurrentTicks();\n    report(\"FVegetation: Built acceleration structures in \"+getSecondsBetweenTicks(start,end)+\"s.\");\n\n    // turn itself off so it doesn't re-evaluate every time the splice node is refreshed\n    prepareMeshes=false;\n  }\n\n  // the key chunk for growing the vegetation which can take more or less time than the\n  // acceleration preparations depending on the number of active buds\n  if(buildGrowth) {\n    // time the vegetation growth process\n    UInt64 start=getCurrentTicks();\n\n    // store an array of references to all buds\n    Bud allBuds[];\n    allBuds.resize(seeds.size());\n    // store an array of buds that are active in the current step for quick access\n    Bud activeBuds[];\n    activeBuds.resize(seeds.size());\n    // store an array of buds that have been active at any point in the growth\n    Bud grownBuds[];\n    grownBuds.resize(seeds.size());\n\n     // create root bud to connect all seeds to, see paper, this is a dummy node in the tree\n    allBuds[0]=(Bud(false, Vec3(0)));\n    // place all seeds into all 3 lists\n    for(UInt32 i=0;i<seeds.size();++i) {\n      Bud seed(true, seeds[i], allBuds[0], samples);\n      allBuds[i]=seed;\n      activeBuds[i]=seed;\n      grownBuds[i]=seed;\n      allBuds[0].addChild(seed);\n    }\n\n    // clear previous meshes that have been output-ed and cleanup associated acceleration structure\n    vegeBranches.removeSpatialQueryAcceleration();\n    vegeBranches.clear();\n    vegeLeaves.clear();\n    // precompute unit conversion\n    Float32 distribAsRads=Math_degToRad(distribution);\n\n    // accumulative loop to build vegetation\n    for(UInt32 s=0;s<steps;++s) {\n      // store the size as used a lot\n      UInt32 buds=activeBuds.size();\n      // only do something if there are any active buds\n      if(buds>0) {\n        // create sample positions for each bud\n        generateSamples<<<buds>>>(activeBuds, samples, distribAsRads, minStep, maxStep, s);\n\n        // prepare an octree for the branches for self collision detection\n        vegeBranches.prepareForSpatialQueries(approxQueries, null);\n        // score each sample position according to distance-to-env and light-seeking tropisms\n        evaluateSamples<<<buds>>>(activeBuds, samples, collideMerged, shadowMerged,\n                                  vegeBranches, branchThick,\n                                  lightPos, lightInt, sunPos, quadratic);\n\n        // kale doesn't have any way of removing elements from an array whilst iterating\n        // through it so instead, need to initialize another array to store elements to keep\n        Bud activeBudsNew[];\n        for(UInt32 i=0;i<buds;++i) {\n          // store a reference to the current iteration for easy access\n          Bud current=activeBuds[i];\n\n          // if the sample isn't fit for growth, traumatically reiterate\n          if(!current.active) {\n            // find the next bud down the n-ary tree structure\n            Bud next=current.findNext();\n            if(next!=null) {\n              // make it active and add it into appropriate lists\n              next.active=true;\n              activeBudsNew.push(next);\n              grownBuds.push(next);\n            }\n          }\n          // otherwise, keep the bud growing\n          else {\n            // apply the new, best position\n            activeBudsNew.push(current);\n            // generate an inactive later bud at random intervals\n            if(mathRandomFloat32(s+8741, i+1)<=budChance) {\n              Bud lateral(false, activeBuds[i].position, current, samples);\n              allBuds.push(lateral);\n              current.addChild(lateral);\n              // make the lateral bud active randomly\n              if(mathRandomFloat32(s+94665, (i+1)*2)<=branchChance) {\n                lateral.active=true;\n                activeBudsNew.push(lateral);\n                grownBuds.push(lateral);\n              }\n            }\n\n            // now draw a quick version of the mesh for collision detection\n            Vec3 direction=current.getDirection();\n            Quat rotation=alignVectors(Vec3(0, 1.0, 0), direction.unit());\n            Xfo xfo[];\n            xfo.push(Xfo(current.prvPosition, rotation));\n            xfo.push(Xfo(current.position, rotation));\n            vegeBranches.addExtrusion(xfo, createProfile(0.04));\n\n            // add the base xfo to an array stored on the Bud\n            current.growth.push(Xfo(current.prvPosition, rotation));\n            // gradually reduce the branch thickness as the steps go on\n            Float32 stepAsFloat=s; // cast to Float32\n            Float32 stepsAsFloat=steps; // cast to Float32\n            current.thickness=1.0-(stepAsFloat/stepsAsFloat);\n\n            // generate a leaf at random intervals\n            if(mathRandomFloat32(s+58192, i+1)<=leafChance) {\n              // offset the leaf position with the surface's normal\n              Vec3 shuffle=current.position+(current.surfaceNormal*leafSize*0.25);\n              // randomise the normal slightly to get varying leaf orientations\n              Vec3 random(mathRandomFloat32(s+13, i+2), mathRandomFloat32(s+581, i+3), mathRandomFloat32(s+8912, i+4));\n              Vec3 normal=(current.surfaceNormal+(random/10.0)).unit();\n              // calculate a turning angle to turn the plane to the normal direction\n              Quat latRotation=alignVectors(Vec3(0, 0, 1.0), normal);\n              // calculate a turning angle to spin the leaf down towards the ground\n              Quat downRotation=Quat(Vec3(1.0, 0, 0), HALF_PI).unit();\n              // combine these rotations to get the final rotation\n              Quat leafRotation=latRotation*downRotation;\n              Xfo xfoLeaf(shuffle, leafRotation);\n              // finally draw a plane as a low-poly leaf\n              vegeLeaves.addPlane(xfoLeaf, leafSize, leafSize, 2, 2, true, true);\n            }\n          }\n        }\n\n        // replace the list of active buds with the new and surviving buds\n        activeBuds.resize(0);\n        activeBuds=activeBudsNew;\n      }\n    }\n\n    // clear the proxy geometry and create a clean mesh using accumulated xfo\n    // from any buds that have previously been active\n    vegeBranches.clear();\n    for(UInt32 i=0;i<grownBuds.size();++i) {\n      // clamp the lowest thickness to 30% original\n      Float32 thickness=Math_max(grownBuds[i].thickness, 0.3);\n      vegeBranches.addExtrusion(grownBuds[i].growth, createProfile(branchThick*thickness));\n    }\n\n    // generate appropriate normals for both meshes\n    vegeBranches.recomputePointNormals();\n    vegeLeaves.recomputePointNormals();\n\n    // count and calculate the processing time\n    UInt64 end=getCurrentTicks();\n    report(\"Vegetation growth took \"+getSecondsBetweenTicks(start,end)+\"s.\");\n    report(\"Current active buds - \"+activeBuds.size()+\", total buds - \"+allBuds.size()+\".\");\n\n    // turn itself off so it doesn't re-grow every time the splice node is refreshed\n    buildGrowth=false;\n  }\n}","portmap":{}}}]}],"extensions":["Vegetation"],"ports":[{"name":"branchChance","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"branchChance","mode":"in","persistence":true,"default":"0.1000000014901161"},{"name":"branchThick","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"branchThick","mode":"in","persistence":true,"default":"0.05999999865889549"},{"name":"budChance","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"budChance","mode":"in","persistence":true,"default":"0.05000000074505806"},{"name":"buildGrowth","node":"DGNode","graph":"mayaGraph","type":"Boolean","autoInitObjects":true,"member":"buildGrowth","mode":"io","persistence":true,"default":"false"},{"name":"collideMerged","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh","autoInitObjects":true,"member":"collideMerged","mode":"io","persistence":false},{"name":"distribution","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"distribution","mode":"in","persistence":true,"default":"30"},{"name":"envCollide","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh[]","autoInitObjects":true,"member":"envCollide","mode":"in","persistence":false},{"name":"envShadow","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh[]","autoInitObjects":true,"member":"envShadow","mode":"in","persistence":false},{"name":"leafChance","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"leafChance","mode":"in","persistence":true,"default":"0.2000000029802322"},{"name":"leafSize","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"leafSize","mode":"in","persistence":true,"default":"0.6000000238418579"},{"name":"lightInt","node":"DGNode","graph":"mayaGraph","type":"Scalar[]","autoInitObjects":true,"member":"lightInt","mode":"in","persistence":true,"default":"[]"},{"name":"lightPos","node":"DGNode","graph":"mayaGraph","type":"Vec3[]","autoInitObjects":true,"member":"lightPos","mode":"in","persistence":true,"default":"[]"},{"name":"maxStep","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"maxStep","mode":"in","persistence":true,"default":"0.5"},{"name":"minStep","node":"DGNode","graph":"mayaGraph","type":"Scalar","autoInitObjects":true,"member":"minStep","mode":"in","persistence":true,"default":"0.004999999888241291"},{"name":"prepareMeshes","node":"DGNode","graph":"mayaGraph","type":"Boolean","autoInitObjects":true,"member":"prepareMeshes","mode":"io","persistence":true,"default":"false"},{"name":"quadratic","node":"DGNode","graph":"mayaGraph","type":"Boolean","autoInitObjects":true,"member":"quadratic","mode":"in","persistence":true,"default":"false"},{"name":"samples","node":"DGNode","graph":"mayaGraph","type":"Integer","autoInitObjects":true,"member":"samples","mode":"in","persistence":true,"default":"32"},{"name":"seeds","node":"DGNode","graph":"mayaGraph","type":"Vec3[]","autoInitObjects":true,"member":"seeds","mode":"in","persistence":true,"default":"[]"},{"name":"shadowMerged","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh","autoInitObjects":true,"member":"shadowMerged","mode":"io","persistence":false},{"name":"steps","node":"DGNode","graph":"mayaGraph","type":"Integer","autoInitObjects":true,"member":"steps","mode":"in","persistence":true,"default":"300"},{"name":"sunPos","node":"DGNode","graph":"mayaGraph","type":"Vec3","autoInitObjects":true,"member":"sunPos","mode":"in","persistence":true,"default":"{\"x\":0,\"y\":0,\"z\":0}"},{"name":"vegeBranches","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh","autoInitObjects":true,"member":"vegeBranches","mode":"out","persistence":false},{"name":"vegeLeaves","node":"DGNode","graph":"mayaGraph","type":"PolygonMesh","autoInitObjects":true,"member":"vegeLeaves","mode":"out","persistence":false}]}